#!/usr/bin/env node

let child_process = require("child_process");
let fs = require("fs");
let path = require("path");

const CWD = process.cwd();
const GRADLE_PROPERTIES = "gradle.properties";
const DEFAULT_TEMPLATE_FILE = "gradle.properties.txt";

const TEMPLATE_FILE = "local.gradle.properties.txt";


let rows = child_process.execSync(`find ${CWD} -name ${GRADLE_PROPERTIES}`).toString().split("\n").
    map(x => x.trim()).filter(x => x.length > 0);

if(rows.length == 0) {
    console.error(`can not find ${GRADLE_PROPERTIES}`);
    process.exit(-1);
}

if(rows.length > 1) {
    console.error(`find multiple ${GRADLE_PROPERTIES}`);
    console.error(" change directory please!");
    console.error(" -> ", rows.join("\n -> "));
    process.exit(-1);
}

let proertyfile = rows[0];

if(!fs.existsSync(proertyfile)) {
    console.error(`${proertyfile} is not found!`);
    console.error(rows);
    process.abort();
}

function parse_item(key, row) {
    let line = row.trim();
    if(line.startsWith(key)) {
        let parts = line.split("=")
        if(parts.length > 0) {
            if(parts[1] && parts[1].length > 0)
            {
                return parts[1];
            }
        }
        return "";
    }
    return undefined;
}


function common_out_items(proertyfile)
{
    let content = fs.readFileSync(proertyfile).toString();
    text = content.split("\n").map((x)=>{
        let store_file      = parse_item("RELEASE_STORE_FILE", x);
        let store_password  = parse_item("RELEASE_STORE_PASSWORD", x);
        let key_alias       = parse_item("RELEASE_KEY_ALIAS", x);
        let key_password    = parse_item("RELEASE_KEY_PASSWORD", x);
        
        if(store_file != undefined && store_file.length == 0) {
            return "# " + x;
        }
        if(store_password != undefined && store_password.length == 0) {
            return "# " + x;
        }
        if(key_alias != undefined && key_alias.length == 0) {
            return "# " + x;
        }
        if(key_password != undefined && key_password.length == 0) {
            return "# " + x;
        }
        return x;
    }).join("\n");

    fs.writeFileSync(proertyfile, text);
}


let test_attribute = fs.readFileSync(proertyfile).toString().split("\n").
    filter((x)=> {
        let store_file = parse_item("RELEASE_STORE_FILE", x);
        let store_password = parse_item("RELEASE_STORE_PASSWORD", x);
        let key_alias = parse_item("RELEASE_KEY_ALIAS", x);
        let key_password = parse_item("RELEASE_KEY_PASSWORD", x);
        return store_file != undefined && store_file.length > 0 ||
            store_password != undefined && store_password.length > 0 ||
            key_alias != undefined && key_alias.length > 0 ||
            key_password != undefined && key_password.length > 0;
    }).length;

if(test_attribute == 0) {
    let template = path.join(__dirname, TEMPLATE_FILE);
    if(!fs.existsSync(template)) {
        console.log(`user template file ${TEMPLATE_FILE} is not found, use ${DEFAULT_TEMPLATE_FILE}`);
        template = path.join(__dirname, DEFAULT_TEMPLATE_FILE);
    }
    const content = fs.readFileSync(template).toString();
    common_out_items(proertyfile);
    fs.appendFileSync(proertyfile,`\n\n## Generated by ${__filename}${content}`);
    console.log("inject release info, done!");
    console.log(`here is the content of ${proertyfile}`);
    console.log("-----------------------------------------");
    console.log(fs.readFileSync(proertyfile).toString());
} else {
    console.log("release info already set?");
    console.log(`please check file ${proertyfile}`);
}
